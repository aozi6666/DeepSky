[https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html](https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html)

## V8引擎工作原理
<font style="color:rgb(44, 62, 80);">V8 在执行一段JavaScript过程中既有解释器 Ignition，又有编译器 TurboFan</font>

> <font style="color:rgb(44, 62, 80);">早期方案：V8无字节码，直接将 AST转换为 机器码 ，执行效果高，但是占用内存大</font>
>

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770693976596-88a2e54e-d9bd-472c-9804-176c784d73cd.png)

流程

1. 生成 抽象语法树(**AST)** + 执行上下文

> **AST 是代码的“结构化语法树”**（把代码变成一棵树，方便机器理解、改写）  
>

JavaScript 源码  --> 抽象语法树（AST)

```javascript
var myName = " 极客时间 "
function foo(){
  return 23;
}
myName = "geektime"
foo()
```

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770694309858-5753bd5e-daf0-4ae2-9aab-aacadf3f5c67.png)

(1) 分词（tokenize), 语法分析： 将 源码 拆分成 Token

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770694428272-64cfdda2-f7de-4cdb-a848-779dd15d78a4.png)

(2) 解析（Parse), 语法分析： 将 语法分析 得到的 Token 按照 语法规则 转为 AST

有 AST后，V8生成改段代码的 执行上下文

2. 生成 字节码

**解释器 logition** 根据 AST --> 生成字节码

**字节码： 介于 AST 与 机器码 之间的一种代码 （所占空间 远小于 机器码）**

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770697602207-9c151ca7-f242-46de-982f-52cf656de5e8.png)

3. 执行代码  -- **<font style="color:rgb(44, 62, 80);">即时编译（JIT）技术</font>**

**解释器 logition **逐条解释执行 字节码

如果 执行字节码过程中，发现 热点代码 HotSpot (一段代码被重复执行多次) --> **编译器 TurboFan **编译为 机器码（运行快但占内存） --> 后续再次执行这段 热点代码，直接执行 编译后的 机器码

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770704415438-b441a146-385b-4223-8516-84d148f9671e.png)



## DOM
 DOM = Document Object Model（文档对象模型）  - DOM：浏览器把 HTML 变成 JS 能操作的对象结构  

> Document ：网页（HTML文档）
>
> Object Model：浏览器（渲染引擎）将页面里的  **标签、文字、图片、按钮……**  变成 **对象**，可以进行操作
>

为什么需要 DOM ？

传输流程：HTML文件字节流  --<font style="color:#DF2A3F;">（通过网络传输)</font>-->  渲染引擎（浏览器）

渲染引擎（浏览器）无法直接理解  HTML文件字节流，需要<font style="color:rgb(44, 62, 80);">转化为渲染引擎能够理解的内部结构  => DOM</font>

#### DOM树：这些对象按<font style="color:#DF2A3F;">父子包含关系</font>组织起来的树状结构  
如何生成DOM树？  

<font style="color:rgb(44, 62, 80);">HTML 解析器（HTMLParser）的模块: 负责将 HTML 字节流转换为 DOM 结构</font>

:::success
 浏览器拿到 HTML（字节流）后：先“分词”变成 Token，再把 Token “组装”成 DOM 节点，并按父子关系插进 DOM 树里。  

:::

代码从网络传输形式为: 字节流

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770624754410-4d5c50ca-f2c4-49ee-b687-c654e3d0e4e9.png)

1. 字节流 --（分词器 Tokenizer ）--> Token

将 HTML 字节流转换为** 文本Token 与 标签Token(开始Tag、结束Tag)**

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770625169686-f2213bcb-e2c7-4a8f-b650-207cb9142271.png)

将 Token 顺序入**<font style="color:#DF2A3F;">栈               </font>**<font style="color:#DF2A3F;">  --</font><font style="color:rgb(153, 153, 153);">该 Token 栈主要用来计算节点之间的父子关系</font>

**<font style="color:#DF2A3F;">  </font>****<font style="color:#DF2A3F;">文本Token 不入栈</font>**

2. <font style="color:rgb(44, 62, 80);">将 Token 解析为 DOM 节点 (Node)</font>
3. <font style="color:rgb(44, 62, 80);">将 DOM 节点添加到 DOM 树</font>

<font style="color:rgb(153, 153, 153);">  第一个阶段中生成的 Token 会被按照顺序压到Token栈中</font>

+ <font style="color:rgb(44, 62, 80);">入栈为 开始标签节点 StartTag Token:  HTML 解析器 为 该TagToken 创建一个 DOM节点，放入 DOM树中（父节点为 栈中</font>**<font style="color:rgb(44, 62, 80);">下相邻</font>**<font style="color:rgb(44, 62, 80);">元素 所生成的节点）</font>
+ <font style="color:rgb(44, 62, 80);">为 文本Token -->不入栈 -->直接创建 文本节点  --> 加入DOM树中（父节点为 </font>**<font style="color:rgb(44, 62, 80);">当前栈顶元素</font>**<font style="color:rgb(44, 62, 80);"> 生成的节点）</font>
+ <font style="color:rgb(44, 62, 80);">入栈为 EndTag Token(比如 EndTag div) --> 查看栈顶元素相匹配 (StarTag div) -->将 StartTag div 从栈中弹出(表示该 div 元素解析完成)</font>

```html
<html>
<body>
    <div>1</div>
    <div>test</div>
</body>
</html>
```

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770626434939-19203920-293e-49ce-ae20-beb7245238ba.png)



<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770626494157-41629fdc-a6da-4a23-aabc-177306165789.png)<font style="color:rgb(44, 62, 80);">  
</font><!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770626398072-78159027-8d67-49e8-a971-fd1b8253f081.png)

...

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770626454313-0b9fb7fd-0166-4c0e-b6fe-c41f38a303ed.png)

#### 面试题：<font style="color:rgb(44, 62, 80);">HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？</font>
<font style="color:rgb(44, 62, 80);">  
</font><font style="color:rgb(44, 62, 80);">HTML 解析器不是等整个文档加载完成之后再解析的，是网络进程加载了多少数据，HTML 解析器便解析多少数据</font>

<font style="color:rgb(44, 62, 80);">流程：</font>

1. <font style="color:rgb(44, 62, 80);">网络进程收到响应头， 根据 content-type 文件类型字段，判断接收的文件文件，如果是 “text/html”（HTML文件类型），为该请求 创建一个</font>**<font style="color:rgb(44, 62, 80);">渲染进程</font>**
2. <font style="color:rgb(44, 62, 80);">网络进程 与 渲染进程 间，建立 </font>**<font style="color:rgb(44, 62, 80);">共享数据 管道</font>**
3. <font style="color:rgb(44, 62, 80);">网络进程接收到数据后，放到 </font>**<font style="color:rgb(44, 62, 80);">共享数据管道</font>**
4. <font style="color:rgb(44, 62, 80);">渲染进程 从 </font>**<font style="color:rgb(44, 62, 80);">共享数据管道</font>**<font style="color:rgb(44, 62, 80);"> 边读取数据边 传递 给 HTML解析器</font>

### <font style="color:rgb(44, 62, 80);">JavaScript 影响 DOM 生成     -- </font>**<font style="color:#DF2A3F;">引入 JavaScript 线程会阻塞 DOM</font>**
```html
<html>
<body>
    <div>1</div>
  
    <!-- JS代码： 对DOM元素的修改 -->
    <script>
      let div1 = document.getElementsByTagName('div')[0]
      div1.innerText = 'time.geekbang'
    </script>
    <!-- JS代码： 对DOM元素的修改 -->

</body>
</html>
```

解析到 script标签 --> HTML解析器 暂停DOM解析  --> JavaScript引擎介入 ->执行script脚本（更新对应的DOM节点）--> 脚本执行完毕，HTML解析器恢复解析 --> ...

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770628069528-db046e3a-9ce4-46d5-afb9-b5c74938d0f6.png)

#### 面试：async 与 defer 加载优化
```javascript
//foo.js
let div1 = document.getElementsByTagName('div')[0]
div1.innerText = 'time.geekbang'
```

```html
<html>
<body>
    <div>1</div>
    <!-- 引入 foo.js 文件 -->
    <script type="text/javascript" src='foo.js'></script>
    <div>test</div>
</body>
</html>
```

<font style="color:rgb(44, 62, 80);">执行 JavaScript 时，需要先下载这段 JavaScript 代码，引发问题：JavaScript 文件的下载过程会阻塞 DOM 解析，通常下载非常耗时</font>

<font style="color:rgb(44, 62, 80);">优化方案：</font>

1. <font style="color:rgb(44, 62, 80);"> Chrome 浏览器 采用 预解析操作</font>

渲染引擎（浏览器）收到字节流后，开启 预解析进程 （分析HTML中的<font style="color:rgb(44, 62, 80);"> JavaScript、CSS等</font>），提前下载这些文件

2. CDN 加速 JavaScript 文件加载，<font style="color:rgb(44, 62, 80);">压缩 JavaScript 文件的体积</font>
3. <font style="color:rgb(44, 62, 80);">如何 js 中没有 操作DOM的操作，将 Javascript 脚本设置为</font>**<font style="color:#DF2A3F;">异步加载（async / defer）</font>**

```javascript
<script async type="text/javascript" src='foo.js'></script>
<script defer type="text/javascript" src='foo.js'></script>
```

async 与 defer 区别（执行时机）：

（1） async：**下载完就立刻执行**

> ** **适合：**统计、广告、埋点**这类不依赖 DOM、也不依赖其他脚本顺序的脚本。  
>

 脚本一旦下载完成，会**打断**当前的 HTML 解析，马上执行它 ,  多个 async 脚本：**谁先下载完谁先执行**（顺序不保证）  

      （2） defer：** 等 DOM 解析完再按顺序执行  **

+ 等 DOM 全部解析完成后, 按它们在 HTML 中出现的顺序依次执行, 触发 `DOMContentLoaded`

### 虚拟DOM
直接修改DOM树，很可能引发重排（触发样式计算->布局->绘制->栅格化->合成），耗时性能下降

+ **<font style="color:rgb(44, 62, 80);">创建阶段</font>**<font style="color:rgb(44, 62, 80);">。根据 JSX+ 基础数据 --> 创建 虚拟DOM树（反映真实DOM树结构）--> 创建 真实DOM树  --> 触发渲染流水线，输出页面到屏幕</font>
+ **<font style="color:rgb(44, 62, 80);">更新阶段</font>**<font style="color:rgb(44, 62, 80);">。数据改变 --> 根据 JSX +</font>**<font style="color:rgb(44, 62, 80);"> 新数据 </font>**<font style="color:rgb(44, 62, 80);">-->创建 </font>**<font style="color:rgb(44, 62, 80);">新</font>**<font style="color:rgb(44, 62, 80);">虚拟DOM树 --> React 比较两棵虚拟DOM树差异(diff找变化) --> </font>**<font style="color:rgb(44, 62, 80);">一次性更新</font>**<font style="color:rgb(44, 62, 80);">到 真实DOM树  --> 渲染引擎更新渲染流水线，生成新页面</font>

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770689288213-612516e2-1dc2-4c99-a588-0bea17e7db3d.png)

#### <font style="color:rgb(44, 62, 80);">React Fiber 更新机制</font>
在执行算法过程中，让出主进程

#### 双缓存 思想
问题定义：游戏开发/图像处理，<font style="color:rgb(44, 62, 80);">图形操作复杂需要多次计算，</font>屏幕从 **前缓冲区 **读取数据并展示

 如果 每次计算完一部分图像，就写入缓冲区  --> 导致 页面一部分一部分显示出来，刷新页面中 用户感到闪烁



使用 **双缓存 **将计算的中间结果存放在另一个缓冲区中，等全部计算结束，将该缓冲区 全部存储数据 **一次性**复制到 显示缓冲区 ，在渲染输出

> <font style="color:rgb(44, 62, 80);">虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，减少一些不必要的更新，保证 DOM 的稳定输出</font>
>

#### MVC 模式
<font style="color:rgb(44, 62, 80);">核心思想：将 数据 与 视图 分离（视图 与 模型间 不允许直接通信，需要通过 控制器）</font>

+ **Model（模型）**<font style="color:rgb(44, 62, 80);">：数据（比如用户信息、购物车列表）</font>
+ **View（视图）**<font style="color:rgb(44, 62, 80);">：界面长什么样（页面展示）</font>
+ **Controller（控制器）**<font style="color:rgb(44, 62, 80);">：接收用户操作（点击/输入），决定怎么改数据、更新界面</font>

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770691231771-82bbe5f2-f117-4e84-bc74-892ff88f6983.png)

<font style="color:rgb(44, 62, 80);">虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供</font>

<font style="color:rgb(44, 62, 80);">Model (模型)  ≈ Redux 的 Store（全局状态）  </font>

+ **Store / state**：集中保存应用数据（比如登录状态、购物车、主题等）  , 组件从 store 读取数据来渲染界面  

 Controller（控制器）≈ action + dispatch + reducer（以及中间件）  

用户操作发生时（点击按钮）：

1. 触发一个 **action**（描述“发生了什么”）
2. 用 **dispatch** 把 action 送到 Redux
3. **reducer** 根据 action 计算出新的 state
4. state 变了 → React 组件收到新数据 → 重新渲染

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770691743761-fd90978d-96f6-4f12-b66c-b5686bf53179.png)

+ 控制器 监视 DOM 变化  --> 控制器通知 模型 更改数据
+ 模型数据更新好后，控制器 通知 视图，通告 模型数据发生了变化
+ 视图 接收到 更新，根据 模型数据 生成虚拟DOM树

## Chrome 开发者工具（简称 DevTools）
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770704840605-55e6d260-55f6-4de7-9f51-2869a7e9f991.png)

### 单个资源时间线（Http请求）
发起http请求 -->浏览器 查找缓存Cache -->没有命中，发起DNS请求 --> 获取IP地址 -->IP地址与服务器建立TCP连接 --> 再次发送http请求 -->等待服务器响应

如果 服务器响应头中包含重定向信息 -->重新跑一边流程

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770705234143-0973feef-07c2-4196-bf1b-5ff73513a3fd.png)

网络面板中的信息解析

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/49848623/1770706310777-91effe41-5051-4ebe-bf01-0356ead425d4.png)

<font style="color:rgb(153, 153, 153);">当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。</font>

+ 页面资源有优先级，CSS、HTML、JavaScript 等都是页面中的核心文件，优先级最高；

                                      图片、视频、音频这类资源就不是核心资源，优先级比较低。

                                      通常当后者遇到前者时，就需要“让路”，进入待排队状态。

+ 浏览器会为每个域名最多维护 **6 个 TCP 连接**，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。
+ 网络进程在为数据**分配磁盘空间**时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。



### 优化时间线上耗时项
#### 排队时间（Queuing）
当打开一个页面，浏览器需要同时下载很多资源：HTML/CSS/JavaScript/图片/字体/接口数据...

** 常见情况：同一个域名（同一个 host）下，浏览器同时最多只能开大约 6 条连接 **

> 例如网站资源在 [https://static.a.com/](https://static.a.com/) 页面需要加载 30 张小图片 + 2 个 JS + 1 个 CSS  
>
>  开始下载：6 张图   其它 24 张图：全在排队  如果这 6 张里有几张特别大，后面排队的就更久  
>

（1）方案1： 域名分片  （Domain Sharding）   HTTP / 1.1

** **技术上该为不同的 host （增加域名）

+ 静态资源域名原来统一用 `https://static.a.com/...`
+ 分片后改成：图片/脚本/样式分别来自 `https://img1.a.com/...`、`https://img2.a.com/...`、`https://img3.a.com/...`

代价：

+  多域名 = 更多 DNS 查询 + 更多 TLS 握手（首次连接会更慢一点）  
+  影响缓存管理、日志统计  

 （2）方案2：使用 HTTP/2  ，支持同域名高并发

Http/1.1 浏览器最多为 同一个域名开启 6 条连接 ， 同一连接中通常 处理一个请求，虽有 _keep-alive_（复用连	接）和 _pipelining_，但现实效果接近“并发能力弱”  

Http/2 **一条连接里可以并发传很多请求/响应**（多路复用 multiplexing） 

>  HTTP/2 的并发能力主要来自 **“一条连接里多条流（streams）并发”**，而不是靠“多开 TCP 连接”(通常1条)  
>

#### 第一字节时间（TTFB）
（1）服务器生成页面数据时间过久

动态页面: 服务器收到请求后-->从数据库读 数据 --> 数据导入模板 --> 模板渲染 --> 返回给用户

优化思路： 让“这次请求”尽量别走**慢的动态生成**，或把动态部分前移到更快的位置。

    -  静态化（SSG）/预渲染（Prerender）  
    -  SSR 但上缓存（HTML Cache / Full Page Cache）  
    -  边缘渲染/边缘计算（Edge Rendering）  
    -  接口聚合（BFF）/减少瀑布请求  
    -  流式 SSR（Streaming SSR）  

（2）网络问题

使用了 **低带宽服务器 ， **<font style="color:rgb(44, 62, 80);">联通的网络用户访问电信服务器</font>

<font style="color:rgb(44, 62, 80);">优化思路： 让内容离用户更近、连接建立更快、协议更高效</font>

    -   CDN（静态资源 CDN / 动态加速）  
    -   HTTP/2 多路复用，减少排队；HTTP/3（QUIC）在弱网/丢包下更稳 
    -   预连接：`preconnect` / `dns-prefetch`
    -   减少重定向  

（3）发送请求头中含有多余用户信息（Cookie）

优化思路：**减小请求头**，尤其是 Cookie；并且避免“每个请求都带一大坨”

    -    把静态资源域名做成“无 Cookie 域名”（Cookieless Domain）  
    -    控制 Cookie 体积与数量  
    -    合理设置 Cookie 的 Domain/Path  
    -    能不用 Cookie 的鉴权就不用  

#### Content Download 时间
<font style="color:rgb(44, 62, 80);">单个请求的 Content Download 花费了大量时间，</font>**<font style="color:rgb(44, 62, 80);">字节数太多</font>**

<font style="color:rgb(44, 62, 80);">优化：减少文件大小（压缩、去掉源码中不必要的注释）</font>

